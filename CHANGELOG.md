# DeliciousBytes Library Change Log

## [1.1.0] - 2025-09-09
### Added
- The `Bytes.encode()` and the `Bytes.decode()` methods now support reversing the order
of the provided bytes via the `reverse` boolean keyword argument; by default bytes are
held and encoded in the order in which they are provided; if the `reverse` argument is
set to `True`, the order of will be reversed; the byte `order` argument has no impact on
the byte ordering of the data, as the `Bytes` type and its subtypes simply hold one or
more individual 8-bit byte values, which are meant to be unaffected by byte order. The
`reverse` argument can be used to reverse the ordering if needed.
- The new `isinstantiable()` utility function can be used to determine if a value can be
instantiated into the specified class type determined based on data type compatibility.
- Documentation for the utility functions in the `deliciousbytes.utilities` submodule.
- Unit testing for the utility functions in the `deliciousbytes.utilities` submodule.

## [1.0.4] - 2025-08-01
### Added
- The `Bytes.encode()` method now pads the generated bytes to the specified length, if a
fixed length has been set for the `Bytes` instance. Padding bytes are added as a prefix
for big endian (MSB) payloads, and as a suffix for little endian (LSB) payloads.

## [1.0.3] - 2025-07-07
### Added
- Input validation for the `.encode()` methods.
- Additional unit testing for the `UnsignedLong` type.
- A new `utilities` sub-module containing the `hexbytes` helper method that can be used
to format raw `bytes` or `bytearray` values into hexadecimal encoded strings for review,
and the `print_hexbytes` helper method that can be used to print such strings.

### Changed
- Type casting of the decoded return value for the `Bytes` class when reversed back to a
`bytes` type, fixing a previous issue where the reversed return type was a `list` type.
- The `BytesView` class `split` length can now be equal to the length of the `data`.
- Corrected type hints for the `BytesView` class' `__iter__` and `__next__` methods.

## [1.0.2] - 2025-06-17
### Added
- Added support for creating `Bytes` values from `bytes` values.
- Added a new `BytesView` class for iterating over `bytes` and `bytearray` objects with
the ability to access the data as arbitrarily sized groups of bytes as well as being able
to cast bytes to specific data types.
- Added `Float`, `Float16`, `Float32` and `Float64` types, as well as `Double` (an alias for `Float64`).
- Added `Size`, `SingedSize` and `UnsignedSize` integer subtypes which have a maximum size dependent upon the system they are running on.
- Added `Unicode`, `UTF8`, `UTF16`, `UTF32`, `ASCII` types to compliment the `String` type; these string variants hold strings with different default character encodings.
- Added `Type` superclass as a parent of all of the type subclasses which makes type comparison and class hierarchy membership easier to discern and allows shared behaviour to be centrally defined and maintained.

### Changed
- The `Short` type was previously unsigned and is now signed as per the C standard following the Python convention; the `Short` type was previously based on embedded metadata standards, which treat `short` as unsigned and defined a separate `signed short`.
- The `Long` type was previously unsigned and is now signed as per the C standard following the Python convention; the `Long` type was previously based on embedded metadata standards, which treat `long` as unsigned and defined a separate `signed long`.
- The `LongLong` type was previously unsigned and is now signed as per the C standard following the Python convention; the `LongLong` type was previously based on embedded metadata standards, which treat `long long` as unsigned and defined a separate `signed long long`.
- A new `UnsignedShort` type has been added to compliment the signed `Short` type and pairs with the `SignedShort` type which is functionally equivalent to `Short`.
- A new `UnsignedLong` type has been added to compliment signed `Long` type and pairs with the `SignedLong` type which is functionally equivalent to `Long`.
- A new `UnsignedLongLong` type has been added to compliment signed `LongLong` type and pairs with the `SignedLongLong` type which is functionally equivalent to `LongLong`.

## [1.0.1] - 2025-06-11
### Added
- Improved input validation for `String.encode()` and `String.decode()`.
- Added support for decoding `String` values from bytes in LSB order.

## [1.0.0] - 2025-06-10
### Added
- First release of the DeliciousBytes library.
